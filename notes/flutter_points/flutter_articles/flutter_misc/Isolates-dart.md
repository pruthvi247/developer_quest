Parallelism refers to the concept wherein more than one task runs simultaneously. It can be run on different codes in the system, or the operating system may handle this differently. On the other hand, in concurrency, more than one task takes turns to execute. There is some approach or system implemented in different languages in which there is a queue and all tasks are present in the queue. There are certain rules for the prioritization of these tasks, which depend on the language and environment.

We have often heard the terms synchronous and asynchronous used in [Flutter](https://geekyants.com/hire-flutter-developers/). In synchronous, the statement or code runs synchronously. The execution of code is in a step-by-step manner

**Isolate —** An isolate is a thread in the Dart environment. Dart is a single isolate environment. Each isolate has its own allocated memory. We are going to look into how we can implement multiple isolates later in this article. For now, we need to remember that each isolate has its own event loop, its own micro-task queue, and event queue.


Let us discuss these in detail.

**Event loop —** Each isolate has its event loop, as seen in the image. Event loop is running all the time, like an endless loop which is running and executing the task.

**Event queue —** The queue which has events that are internally triggered. All the input coming from the user, such as gesture, drawing, timer, streams, all these statements are present in the event queue.

**Micro-task queue —** All the processes which are generated by the internal actions are handled by the micro-task queue. Anything that is system generated is handled by the micro-task queue because they have higher priority than the tasks initiated by the user.

![[Pasted image 20231116081736.png]]

So, in an isolate, the event loop first finishes the micro-task queue tasks. After finishing these tasks, the event loop starts taking tasks from the event queue. We can understand this with the help of a flow diagram.

Here, we can see that in the main thread’s representation, the event loop is running (in the beginning), and it is checking whether the micro-task queue is empty. If it is not empty, it will take out the first micro-task in the queue and execute it and if all the tasks of micro-task queue are finished, then it will go to the event queue and execute all the tasks event queue.

## Isolates

When you start your flutter app , a new thread process is created and launched. In dart language, this thread process is called isolate

- 1 Isolate has one event loop and 2 queues (micro task and event queue)
- Isolate does not share memory, code that runs in isolate is independent of another.
- Communication between different isolates is made via messages , The receiving isolate process messages using its event loop 
- Many Dart apps work in single isolate, but you can have more than one if needed.
Dart is a single-threaded environment. If we do not create it explicitly, all the operations and tasks are going to be run on a single main isolate.

Suppose we have some heavy computation code to run , in this case doing task in async method will most likely cause lag in application.

Suppose there is a situation where we want to perform some big computational task. For example, we want to run a background API call, which is very heavy and takes a lot of time. Or, we want to download a large file. But at the same time, we do not want to disturb the flow of UI in the app

In order to handle these situation, a solution would be to create another isolate and then perform that high computational task in the newly created isolate in the background. The main isolate will be running parallelly, and everything will run smoothly.

There are two ways to create isolates in Dart. There is also an external package for this but here we discuss the two ways we just talked about:

- **Isolate.spawn() function**
- **Compute() function**
[Async vs isolate philip harcer-video](https://www.youtube.com/watch?v=5AxWC49ZMzs)

### Conceptual Differences between Asynchronous Processing and Isolates

Asynchronous processing and Isolates are two different ways of achieving concurrency in Dart and Flutter. While asynchronous processing allows tasks to run in parallel without blocking the main code execution, Isolates provide a way to perform more CPU-intensive tasks in separate threads.

### Practical Differences between Asynchronous Processing and Isolates

Asynchronous processing is suitable for tasks that involve I/O operations, such as network requests or reading from and writing to a file. On the other hand, Isolates are more suited for CPU-intensive tasks that need to be run in parallel without affecting the performance of the main thread.

### When to use Asynchronous Processing and when to use Isolates

- **Asynchronous Processing**: This is ideal for tasks that involve I/O operations, such as network requests, file operations, and accessing device APIs. Asynchronous processing ensures that these operations do not block the main thread and the user interface remains responsive.
- **Isolate**: An Isolate is suited for CPU-intensive tasks such as image processing, data processing, and encryption. By running these tasks in an Isolate, you can ensure that the main thread remains free to handle UI operations.

You might be wondering something: If Dart is a single-threaded language, how can asynchronous tasks in Flutter _(like fetching data via an HTTP call)_ perform optimally without hindering other activities of the application? Well, this leads to two different concepts, **concurrency** and **parallelism**, the former standing for async tasks and the latter for tasks running on an isolate. To understand these concepts, let’s cook up two scenarios.

#### Scenario 1 (concurrency)

You decide to go get a coffee in the coffee shop. _(Assume that the coffee shop is an enclosed room with just a door.)_ There’s a long queue, but you decide to wait for your turn regardless. The barista _(the person who prepares and serves the coffee drinks)_ processes the orders of each next customer in the queue, one after another.

Let’s say there’s a shift change between **barista A** and **barista B**. This delays the process of ordering a coffee, so the customers have to wait for barista B to take over and resume serving coffee to the next customer in line to get the queue moving again. The transition between barista A and barista B does not otherwise impede the actions of the customers, as they can still talk to each other, move their bodies, and so on.

Asynchronous code in Dart works in a similar way. When you use the `await` keyword on an `async` task, other parts of the program keep running, and when the `async` task is completed, the program resumes from the next line of code. An `async` task is a Dart event loop jumping between different parts of your program _(processing events)_ as needed. The code sample below shows this in action.
```dart
void asyncTask() async {
   /// Waits for this 5 seconds to elapse
   final result = await Future.delayed(Duration(seconds: 5));
   /// Then proceeds to run other lines of code
   /// While waiting, this does not block off other programs running
   print(result);
 }
```
#### Scenario 2 (parallelism)

This time, you and your friend decide to go to the coffee shop, but the first shop has a long queue and a lot of delays. So your friend decides to go to the next coffee shop, leaving you in the first coffee shop.

In this scenario, we can say that the process of you getting a coffee in the first coffee shop and your friend getting a coffee in the next coffee shop is happening in a parallel manner, as whatever happens in the first coffee shop does not affect the next coffee shop.

For creating isolates and messages refer blog : https://techblog.geekyants.com/isolates-in-dart-and-flutter

