[Source](https://medium.com/@fluttergems/mastering-dart-flutter-devtools-series-introduction-installation-part-1-of-8-4f703a8cfcc8)
#### Intro
- **Flutter Inspector** — It is a visual tool useful for inspecting UI layout, tweaking UI elements, diagnosing layout issues and exploring the widget tree of a Flutter app. You can take a deep dive into Flutter Inspector tool in our article — [**here**](https://medium.com/@fluttergems/mastering-dart-flutter-devtools-part-2-flutter-inspector-bbff40692fc7).
-   **App Size Tool** — This tool can be used to visualize and inspect the total size of the app via hierarchical chart display. It can also be used to analyze and visualize any difference in the total size of two apps (old vs updated version). You can read more about App Size tool in our detailed article — [**here**](https://medium.com/@fluttergems/mastering-dart-flutter-devtools-part-3-app-size-tool-9be6e9ec42a2).
-   **Network View —** Any HTTP, HTTPS or web socket traffic from your application like REST API calls, network image downloads, json responses, etc. can be monitored using the Network View tool. You can learn more about Network View tool in our detailed article — [**here**](https://medium.com/@fluttergems/mastering-dart-flutter-devtools-part-4-network-view-afce2463687c).
-   **Logging View** — This tool is useful for monitoring diagnostics information and logs generated by the framework and by the user while running an app. It is a good practice to use Logging View instead of browsing the standard output as the logs are labeled, much better organised and are not truncated allowing granular inspection. You can read more about Logging View tool in our detailed article — [**here**](https://medium.com/@fluttergems/mastering-dart-flutter-devtools-part-5-logging-view-b634f3a3af26).
-   **CPU Profiler View** — This tool enables us to monitor the CPU usage of a Flutter app and investigate any performance issue that might exist due to higher execution time of any piece of code. To learn more about CPU Profiler View tool, check out our detailed article — [**here**](https://medium.com/@fluttergems/mastering-dart-flutter-devtools-part-6-cpu-profiler-view-31e24eae6bf8).
-   **Memory View** — This tool helps in visualizing the memory usage of a Dart or Flutter app and is useful for inspecting objects and detecting any memory leaks that lead to an app crash. You can learn more about Memory View tool in our detailed article — [**here**](https://medium.com/@fluttergems/mastering-dart-flutter-devtools-part-7-memory-view-e7f5aaf07e15).
-   **Performance View** — This tool is useful for capturing and visualizing timing and performance metrics like rendering frame per second (FPS) that can help us detect any UI jank (Slow Frame Rate) in a Flutter app. To learn more about Performance View tool, check out our detailed article — [**here**](https://medium.com/@fluttergems/mastering-dart-flutter-devtools-part-8-performance-view-4ae762f91230).
-   **Debugger —** A source level debugger is also provided in DevTools that can be used to step through the code using breakpoints and we can inspect the value of variables. As VS Code has a built-in debugger, this tool is only visible if the app is run via Android Studio or via command line.

**Availability of dev tools based on the type of app:
![[Pasted image 20230111074759.png]]
> The above table only states the availability of these tools in Dart DevTools and does not imply that you cannot optimize and analyze your Flutter Web Apps. Browser tools such as the [Chrome DevTools](https://developer.chrome.com/docs/devtools/) can be used for that purpose

#### Flutter inspector:
The Flutter Inspector window has three major parts:

1.  Toolbar
2.  Widget Tree Pane
3.  Layout Explorer / Widget Details Tree Pane
![[Pasted image 20230111084247.png]]

Flutter Inspector’s toolbar provides features that help in debugging layout issues visually. To activate any feature you just need to press the corresponding button in the toolbar. The available features are:

-   **Select Widget Mode —** Widgets can be selected in the interactive Widget Tree Panel to inspect their properties. But, this can be cumbersome in case the widget tree is deep. Enabling this mode allows the user to select a widget directly on the app’s UI, so that it can be further inspected.
-   **Slow animations** — When slow animations is enabled, all animations runs 5 times slower allowing for easy visual inspection. It is useful for observing and tweaking any animation that might not look fully right.
-   **Show guidelines** — When this feature is enabled, guidelines are drawn in the app displaying render boxes, alignments, paddings, scroll views, clipping and spacers. This tool can be used to better understand and modify the layout such as better aligning the widgets or removing any unwanted padding.
-   **Show baselines** — This tool is useful for visually inspecting the alignment of texts using baselines that are horizontal lines used for positioning texts. Selecting this option will make all the baselines visible, allowing you to precisely check the vertical alignment of the text.
-   **Highlight repaints** — This tool is useful for highlighting the widgets that are repainting frequently, that can hamper the performance of the app. Every time a box repaints, a border is drawn around it in a rotating rainbow colour.
-   **Highlight oversized images** — As the name suggests, this tool highlights high resolution images that are using too much memory by inverting colours and flipping them. Fixing these images is important as they can cause poor performance, especially on lower end devices and in case you have many images on the screen like in a GridView or a ListView.
#### App size tool

**Running the Size Analysis Tool in VS Code Terminal**

Compared to other tools that can run in debug or profile mode, App Size Tool requires generation of a unobfuscated release build that contains no debugging overhead and is close to the production version of an app the end user would download and install.

In the VS Code shell shown above, the size analysis tool can be invoked by passing the `--analyze-size` flag while building the release version using one of the following commands:
-   `flutter build apk --analyze-size` (any host)
-   `flutter build appbundle --analyze-size` (any host)
-   `flutter build ios --analyze-size` (only macos host)
-   `flutter build linux --analyze-size` (only linux host)
-   `flutter build macos --analyze-size` (only macos host)
-   `flutter build windows --analyze-size` (only windows host)
For this exercise we will build an [Android App Bundle](https://developer.android.com/guide/app-bundle) and perform a size analysis on it by executing the below command:

`flutter build appbundle --analyze-size`
The following error message will be displayed —

```
Cannot perform code size analysis when building for multiple ABIs.  
Specify one of android-arm, android-arm64, or android-x64 in the  
— target-platform flag.
```
As there are [three main CPU architectures](https://developer.android.com/ndk/guides/abis) — ARM (`android-arm`), ARM64(`android-arm64`), or x86(`android-x64`) in Android devices, we have to specify the target platform for code size analysis as the compiled binaries differ based on the target platform. The same is true in case you want to perform size analysis while using `flutter build apk` command.

ARM64 is becoming the standard in newer android devices, so we will choose the target platform as `android-arm64` and execute the following command:

`flutter build appbundle --analyze-size --target-platform android-arm64`
Post execution, the size analysis tool records the size of all resources and packages post code compilation. A summary drill-down of the app size is also displayed and a detailed size analysis is saved in `*-code-size-analysis_*.json` file.

##### Launching the Size Analysis Tool Page

**1. Using VS Code Terminal**

In case DevTools is not activated, run the following command in the VS Code terminal:

`flutter pub global activate devtools`

Now, you can launch the App Size Analysis tool and preload it with the generated size snapshot data directly using the command(s):

`flutter pub global run devtools --appSizeBase=*-code-size-analysis_*.json`

**Using VS Code Status Button**

Click on **Dart DevTools** in the VS Code Status Bar.
![[Pasted image 20230111085406.png]]
Now, click on the `Open app size tool` button to open the App Size Tool page as shown in the image below.
![[Pasted image 20230111085427.png]]
Left top of this page, you can see the two types of size analysis options that are available - **Analysis** and **Diff**.
-   **Analysis** — Helps you drill-down deeper into a single size information snapshot (file). This will be covered in the current scenario.
-   **Diff** — This is useful for comparing two size information snapshots. It is used for cases when we want to visualize size changes between two snapshots (old ver. vs new ver.) after performing some app optimization. We will cover it in detail in Scenario #2.
##### Using the App Size Tool

In the current scenario (Scenario #1), we want to perform the size analysis of a single snapshot. So, we will focus on the Analysis tab.

Click **Import File** and select the `*-code-size-analysis_*.json`file by navigating to the path displayed on the terminal.
After selecting the file, just click on `**Analyze Size**` to open the size analysis of the snapshot.You can immediately witness a hierarchical tree visualization (Treemap). Below this Tree-map, the snapshot size data is also available in the form of an explorer view table.

>  [Obfuscate your app](https://docs.flutter.dev/deployment/obfuscate#obfuscating-your-app) to dramatically reduce code size.

##### Dominator Tree or Call Graph

The Dominator Tree or Call Graph is another section of the App Size tool. One can switch between both the modes using the Toggle Switch button.
A dominator tree (shown below) is useful for understanding the root cause of existence of a piece of code in the application, where the package tree is arranged in such an order that each node’s children are those nodes that are immediately dominated by the parent.
![[Pasted image 20230111090228.png]]
For example, in the dominator tree of the wonders app (shown above), the `package:url_launcher` (child) is dominated by `package:youtube_player_iframe` (parent), as all paths to `package:url_launcher` goes only through `package:youtube_player_iframe` .

In case you want to get a better idea of the dependencies between the pieces of codes (packages) in order to understand why some code is included, Call graph can be used.
![[Pasted image 20230111090307.png]]
For example, in the above Call Graph of `package:youtube_player_iframe`, we can observe that the wonders package calls it and it in turn calls `package:url_launcher` , `package:flutter_inappwebview` and other packages mentioned on the right.

#### Network View
**Network View** tool helps us monitor and inspect any HTTP, HTTPS or web socket traffic from a Dart or Flutter application.

If you take a look at the bottom of the page, a circular progress indicator is visible, which indicates that the network traffic is being recorded.

You can pause the monitoring of network traffic by clicking on the **Pause** button on the top-left corner of the page.

![[Pasted image 20230111092032.png]]

#### Logging View
If this `message` is too large then some log lines may get discarded or truncated due to the printing limit of the OS (such as Android).

To circumvent this, we can use `[debugPrint()](https://api.flutter.dev/flutter/foundation/debugPrint.html)` function from Flutter’s `foundation` library which can be modified via assigning it to a custom `[DebugPrintCallback](https://api.flutter.dev/flutter/foundation/DebugPrintCallback.html)` that can throttle the rate at which messages are sent to avoid data loss in Android. You can also provide a `wrapWidth` argument that word-wraps the `message` to the given width so as to avoid any truncation of the output.
```dart
import 'package:flutter/foundation.dart' show debugPrintThrottled;  
  
// if no wrapWidth is provided then automatically set it to 70 characters  
final debugPrint = (String? message, {int? wrapWidth}) {  
debugPrintThrottled(message, wrapWidth: wrapWidth ?? 70);  
};  
  
void main() {  
var message = "Hello logger!";  
debugPrint(message);  
  
var longMessage = "A very long line that is automatically wrapped by the function so that it does not get truncated or dropped.";  
debugPrint(longMessage);  
}
```
Although both the above functions can be used for logging, the output of `print()` and `debugPrint()` functions can be viewed easily as they are displayed in the terminal even if the app is in release mode. You can actually go ahead and run the `flutter logs` or or `adb logcat | grep flutter` command in the terminal and observe the logs generated using these functions while running the app. This can lead to security issues if any sensitive information or any authorization process related information is being logged in your app due to the usage of these functions.

`debugPrint()` does have the option to prevent this as it can be customized to work only in dev mode by giving and empty callback as shown below.
```
void main() {  
if (kReleaseMode) {  
debugPrint = (String? message, {int? wrapWidth}) {};  
}  
}
```
##### log()

Apart from security concerns, the `print()` and `debugPrint()` functions are also not very helpful for log analysis as they lack features to add granularity, perform customization and display additional information while logging.

This is where the `[log()](https://api.flutter.dev/flutter/dart-developer/log.html)` function available in the `dart:developer` library comes to our rescue. Apart from displaying the `message` that represents the log message, there are some other useful parameters provided in this function that can help us add granularity and data to our logs, such as:

-   `name` (`String`) — A short string that can quickly help you locate the source of the error. In the Logging View, it becomes the value of the `Kind` field and can be directly used for filtering logs. If this value is not specified then the default value of the column is `log`.
-   `error` (`Object?`) — An error object is usually the application data at that point in the workflow (event) that we might want to investigate. This data is passed and can be viewed in the Logging View.
-   `level` (`int`) — Denotes the severity level (a value between 0 and 2000). You can use the `package:logging` `[Level](https://pub.dev/documentation/logging/latest/logging/Level-class.html)` class to get an overview of the possible values. If the value is equal to or above `1000` (`Level.SEVERE.value`), the log’s `Kind` field in the Logging View is highlighted in Red for the log to stand out.

The logs generated using `log()` are not displayed on the terminal which makes it secure. We can view these logs using the DevTools’ Logging View as described in the next section.
```
log(  
"Log Event: Short String",  
name: "buttonLog",  
error: kShortString,  
);
```
##### Filtering Required Logs

Events like Flutter frame events (`flutter.frame`) and garbage collection events (`gc`) captured in the Logging View that are not useful for our investigation can be filtered out using the filter option as shown below.

Just click the `Filter` button and enter `-k:flutter.frame,gc` to hide all logs of kind `flutter.frame` and `gc`. In case you want to view logs of only a certain kind that you specified (like `buttonLog` events), just enter `k:buttonLog` in the filter text field and it will display only the logs of that kind.

This is a powerful feature of Logging View that can selectively show only the relevant logs and help us analyze them.
![[flutterlogginview.gif]]
#### CPU Profiler View
We should run app in **Profile mode**

There are three primary buttons — `Record`, `Stop` and `Clear` that can be used to start CPU profiling, stop CPU profiling and to remove all CPU usage data, respectively.
There are also some more CPU profiler options available on the top-right as shown in the image below.
![[Pasted image 20230111100524.png]]
These options are:

-   **Profile app start up**: This button loads all CPU samples that occurred before the first Flutter frame was drawn. In case there is a delay in app startup, this helps in identifying the underlying functions that cause the delay. To learn more about app startup and how it is important to have a low startup time, you can check out [this article](https://developer.android.com/topic/performance/vitals/launch-time).
-   **Load all CPU samples**: This button loads all available CPU samples from the profiler that includes data pertaining to remaining isolates apart from the main isolate. We will look into this feature later in this article (in **Scenario #2**).
-   **Profile granularity**: The default (medium) rate of collection of CPU samples is 1 sample per 250 microseconds. Based on the requirement, this setting can also be modified and set as 1 sample per 1000 microseconds (low granularity) or 1 sample per 50 microseconds (high granularity).
-   **Export**: The collected CPU samples data can be exported using this option.

##### 1. Bottom Up

The Bottom Up tab (as shown in the image below) shows the list of functions or methods (along with their source file location) that are called last in the call stack for a given CPU sample. These functions are ordered by their execution time, with the longest running function at the top of the table. Apart from absolute numbers, the execution time of these functions are also shown as a percentage of total runtime which is useful for identifying the functions/methods that need our urgent focus.
##### 2. Call Tree

The Call Tree (as shown in the image below) is a top-down representation of the entire call stack, that makes it exactly opposite to the Bottom Up table. One can expand a method by clicking on it to show the methods it is calling.
##### 3. CPU Flame Chart

The CPU Flame Chart (shown in the image below) visualizes the timeline of CPU usage using a top-down stack trace. This is presented as a stack of method calls where each method calls the method below it and the width of each method call is equal to its run-time.
In this Flame chart, the methods belonging to core Dart and Flutter libraries are coloured Lavender Blue, and user defined methods and methods belonging to 3rd party packages are coloured in Pale Orange. 

If we creat a isolate for performance of expensive task , we have to press **load all cpu samples ** to load isolates data

![[flutterisolates.gif]]

#### Memory View
Memory leak can be detected by analyzing the Heap Snapshot in the Memory View. These snapshots can be used to compare the growth of heap and detect objects that might experience unexpected increase in count. You must remember that although images and media have a high memory footprint they might not be the main cause of memory leaks.

![[Pasted image 20230111103316.png]]
The above diagram shows the various types of objects present in the heap:

-   The green circle represents the objects in the heap whose references still exist in the stack.
-   The red circle represents the objects in the heap that are currently not being used. You might expect the GC to remove all of these unused objects, but thats not the case.
-   GC only removes objects whose references no longer exist in the stack, that is represented as the non-intersecting portion of the red circle.
-   There may still be some unused objects in the heap (intersection) that still have references in the stack. Failure to remove these objects from the memory is known as **Memory Leak** as these objects still occupy the memory even if they are not being used by the app.

By default, Memory View constantly collects the memory usage data as it can be seen in the Memory overview chart
The length of the timeline can be changed by clicking on the `Display Default` option as shown below. We will not change it for the current use case.
![[Pasted image 20230111103614.png]]

#####  Taking the 1st Heap Snapshot Using Memory View

Let us take an initial snapshot of the heap after launching the app by clicking on the `Take Heap Snapshot` button in the Analysis tab as shown below. Also, if you take a look at the overview chart, a green circle appears in the timeline indicating that we took a manual snapshot.![[devtoolssnapshot.gif]]

If we go ahead and click on the Memory Overview Chart, the memory usage details at that particular instant is displayed as shown below.
Various quantities that are displayed on the chart is as follows:

-   **RSS or Resident Set Size**: The resident set size (RSS) is the portion of a program’s memory that is currently loaded into RAM and is available for immediate use. It can be thought of as the “working set” of a program, as it represents the memory that is actively being used to execute the program’s instructions. It includes all stack and heap memory along with the memory from loaded shared libraries.
-   **Allocated**: Allocated memory refers to the portion of a computer’s memory that has been reserved for use by a specific program or process and is not available for use by other programs or processes. It is typically used to store the program’s instructions, data, and other necessary information. It is important to manage allocated memory carefully, as **running out of allocated memory can cause a program to crash or otherwise malfunction**.
-   **Dart/Flutter**: Memory occupied by Dart and Flutter objects in the heap.
-   **Dart/Flutter Native**: Memory occupied by the native objects exposed to the Dart VM by the native OS.
-   **Raster Layer**: The size of the Flutter engine’s raster cache layer(s).
-   **Raster Picture**: The size of the Flutter engine’s raster cache picture(s).
##### Detecting Memory Leaks

To simulate a memory leak we will create 1 million instances of `MemoryLeakObject` on each button press and add it to the list `leakObjects` as demonstrated in the code below.
```dart
class MemoryLeakObject {  
final String text;  
  
MemoryLeakObject(this.text);  
}  
  
List<MemoryLeakObject> leakObjects = [];  
  
class MemoryLeaksScreen extends StatelessWidget {  
const MemoryLeaksScreen({super.key});  
  
@override  
Widget build(BuildContext context) {  
return Scaffold(  
body: Center(  
child: ElevatedButton(  
child: const Text(  
'Add 1M Leaky Objects',  
),  
onPressed: () {  
var i = 0;  
while (i < 1000000) {  
leakObjects.add(  
MemoryLeakObject('Id: ${leakObjects.length}'),  
);  
i++;  
}  
},  
),  
),  
);  
}  
}
```
Let us now go ahead and press the `Add 1M Leaky Objects` button.

You can observe the increase in usage of memory after pressing the button as shown below.
![[Pasted image 20230111104447.png]]
Press `Take Heap Snapshot` to take a snapshot of the current heap. The count of the number of objects in the heap has now increased by `~1M` as it can be seen in the `Count` column. On further traversing the snapshot, we can see that exactly 1M instances of `MemoryLeakObject` has been created and they occupy 15.3 MB memory.
![[Pasted image 20230111104535.png]]
By clicking on the **Treemap** switch, as shown below, you can view the memory footprint of all objects in the heap as a 2D hierarchical tree chart. This helps in detecting the objects occupying more memory along with their location in the source files.

Let us now click the button again and observe the increase in memory usage as shown below.
The details of memory usage can be seen below. The heap of Dart and Flutter objects now occupy `58.25 MB` memory compared to `29.39 MB` they occupied earlier. Also, the total allocated memory has increased from `44.38 MB` to `67.38 MB`.
![[Pasted image 20230111104714.png]]
Press `Take Heap Snapshot` to take a snapshot of the latest heap. The count of the number of objects in the heap has increased further by `~1M` as it can be seen in the `Count` column. On further traversing the snapshot, we can see that exactly 1M new instances of `MemoryLeakObject` has been created (total `2M`) and they occupy 30.5 MB memory.

![[Pasted image 20230111104746.png]]

#### Performance View
As soon as we open the Performance View, we can see “Shader compilation jank detected” error as shown in the image below.This jank happens on the first app run and is currently being addressed in the latest rendering runtime for Flutter — Impeller. You can read more about it [here](https://github.com/flutter/flutter/wiki/Impeller). As this issue will get resolved in near future, we will not cover it in this study.

**1. Toolbar
![[Pasted image 20230111105346.png]]
An option is also provided to add a Performance Overlay directly on the app.
On enabling the Performance Overlay, frame statistics for the last 300 frames along with aggregates (max. rendering time, avg. rendering time) are directly displayed on the app as shown below.
![[Pasted image 20230111105243.png]]
The upper graph is for the time spent in the Raster thread (scene rendering) and the lower graph is for the time spent in the UI thread (Dart code execution) while building a frame. The vertical green bars represent the current frame.

**2. Flutter Frames Chart**
This chart presents the application’s frame information, with each set of coloured bars representing a single Flutter frame. In order to avoid any janking, a frame should be created and displayed within **1/60th of a second (~16ms)**. If a frame exceeds this limit, the bar is coloured in red to indicate a janked frame. If the UI frame time bar is red, it means that the Dart code is too expensive. In case the Raster frame time bar is red, it implies that the scene (graphics) is too complicated to render quickly.
![[Pasted image 20230111105505.png]]
![[jankeddevtools.gif]]

**3. Timeline Events Chart**
The Timeline Events chart provides a deeper analysis of each frame. When a bar is selected in the Frames Chart, the corresponding timeline details are highlighted in this flame chart.

**4. CPU Profiler Details**
When an event is selected in the Timeline events chart, its entire CPU profiling information is presented in this window.