=======================
======= Docker ========
=======================
Create snapshot/image out of container:
———————————————————-------------------

> docker  commit -c ‘CMD[“name of image”]’<container id>
	- to create image out out of container

dockercompose commands:
----------------------

> docker-compose up -d
> dociker-compose ps
> docker-compose down
> docker-compose up --build
> docker-compose ps will look for docker-compose.yml file,
 so we should execute in the same folder where we have compose file

sample docker compose file:
-------------------------
version: ‘3’
Services:
	resids-server:
		image: 'redis'

	node-app:
		restart: always
		build: .
		ports:
			- "4001:8081"

Duplicating Dependencied:
-------------------------
docker volumes:
	> syntax : docker run -p port:port -v /workdir/folerpathinsidedocker -v $(pwd):/workingdirectory <image id>

		{ 

		form above syntax -v with ":" says that map the folders inside docker to source folder of host machine
			-v with out ":" says that don't map the path in docker to host machine and take everying form docker

		-> example : docker run -it --name <imageid> -p 8080:80 -v /sourceDirectory/:/wokingDirectory

		-> docker run -p 8165:8888 -d -it --rm --name scaling_demo_mani --mount type=bind,source=/home/manikandan.ramar/pyscale/scaling-demo/,target=/usr/src/app py_scale_image_mani

		}
	docker-compose for volume mounting :
					version: ‘3’
					Services:
						resids-server:
							image: 'redis' 

						node-app:
							restart: always
							build: 
								context : /path_to_dockerfile
								dockerfile: Dockerfile_name
							ports:
								- "4001:8081"
							volumes:
								- /path_not_to_map
								- /path_outside_container:/path_inside_container
Docker Attach:
-------------
> docker attach will connect host terminal to stdin,stdout,stderror of container

multi step docker build:
----------------------
docker file:
{
	when we want the funtionality of two images we use multi tstep docker build,where we create temporary image and copy contents of that to second container.so in the below exampe we first built an image node:alpine and install dependecies, after that we are copying folder from the image that has been built to second image/container that is nginx,in the case of nginx it is /usr/share/nginx/html which is workdir.
}

FROM node:alpine as builder
WORKDIR /usr/src/app
COPY . .
RUN npm install
RUN   npm run build

FROM nginx
COPY --from=builder /path_to_folder_in_firstimage /path_to_folder_second_image

Environment Variables:
----------------------
1) set a variable in the container at run time.(variableName=value)
2) set a variable in the container at run time ,value is taken form "host machine",(variableName)

docker-compose.yml:

version: ‘3’
Services:
	resids-server:
		image: 'redis' 

	node-app:
		restart: always
		build: 
			context : /path_to_dockerfile
			dockerfile: Dockerfile_name
		ports:
			- "4001:8081"
		volumes:
			- /path_not_to_map
			- /path_outside_container:/path_inside_container
		environment:
			- REDIS_HOST = "redis-server"
			- REDIS_PORT = "6379 "
	nginx:
		restart:always
		build:
			dockerfile : Dockerfile.nginx
			context: ./nginx
		ports:
			- '9000:80'


Q: How to check docker image details?
> docker inspect <imagename or image id>

Q: How to get the details of each layer of docker image ?
> docker history <image name/id> or docker history <image name/id> --no-trunc

Q How to remove dangling images ?
> docker image prune

Q How to run container in interactive and daemon mode ?
> docker run -itd --name <container name> <image name>
-it for interactive and tty
-d for daemon/detached mode

Q How to check details of container ?
> docker inspect <container id>

Q How to find the size of container writable layer ?
> docker ps -as

Q How to check logs of a container ?
> docker logs <container name/id>
> for live stream of logs- docker logs -f <container id/name>

> docker logs are not stored inside the container.

Q Is there any way to restart containers if host machine of docker engine restarts
> docker run -itd --restart-always --name <Container name> <Image name>

Q Is there a way to clean up the containers created by developers 
> Start a container with remove flag
> docker -itd --rm --name <Container name> <Image name>
Q Can we use restart and rm flag at same time while starting the container
> No, Conflicts occur

Name space : Name spaces are responsible for isolation between the containers. Type of name spaces are PID, user,filesystem ...
Cgroup : Cgroup is responsible for resource management or resource utilisation/limitation in each container. It manages CPU, memory, network,Block I/O 
UnionFS : Union File System is responsible for creating docker image layer,this file sytem is responsible for reusing the same image for different containers

Volumes vs Bind Mounts

With Bind Mount, a file or directory on the host machine is mounted into a container. The file or directory is referenced by its full or relative path on the host machine.
With Volume, a new directory is created within Docker's storage directory on the host machine, and Docker manages that directory's content.

Bind mounts

Available since the early days of Docker. Bind mounts have limited functionality compared to volumes. When you use a bind mount, a file or directory on the host machine is mounted into a container. The file or directory is referenced by its full path on the host machine. The file or directory does not need to exist on the Docker host already. It is created on demand if it does not yet exist. Bind mounts are very performant, but they rely on the host machine’s filesystem having a specific directory structure available. If you are developing new Docker applications, consider using named volumes instead. You can’t use Docker CLI commands to directly manage bind mounts.

Bind mounts: A bind mount is a file or folder stored anywhere on the container host filesystem, mounted into a running container. The main difference a bind mount has from a volume is that since it can exist anywhere on the host filesystem, processes outside of Docker can also modify it.

Volumes: Volumes are the preferred way to store persistent data Docker containers create or use. The host filesystem also stores volumes, similar to bind mounts. However, Docker completely manages them and stores them under C:\ProgramData\docker\volumes by default.

Q: Can we talk to docker daemon from inside a docker container ?
> If we can mount /var/run/docker.sock file the we can do it
eg : docker run -itd -v /var/run/docker.sock:/var/run/docker.sock --name <Container name> <Image>

> Now we can do all the docker operations from inside the container

Q: docker stop vs docker kill
> docker stop will look for any existing request and stop, docker kill will abruplty stops the container even if requests are in pending state

Q: Is it possible to copy a file in to the containers that is few running and few stopped with out starting the container ?
> docker cp secret.cong <Container name>:/home/destination/folder
> After we start the container we will be able to see the file inside the container

Q: Docker Arg instruction
> 
ARG VERSION=latest
FROM busybox:$VERSION

> docker build -t <image-name>:<tag> --build-arg <key1>=<value1> --build-arg <key2>=<value2> .


Difference Between ENV and ARG
It is evident from the above that ARG instruction can only be accessible during build time and not available when we are running the container. It can be passed with the build command with the flag --build-arg.
ENV instruction is available during build time and also when running the container with the flag --env. But, we can’t pass ENV instruction while building the image.

WORKDIR:

The WORKDIR command is used to define the working directory of a Docker container at any given time. The command is specified in the Dockerfile.

Any RUN, CMD, ADD, COPY, or ENTRYPOINT command will be executed in the specified working directory.
>>>>
FROM ubuntu:latest
WORKDIR /my-work-dir
RUN echo "work directory 1" > file1.txt
WORKDIR /my-work-dir-2
RUN echo "work directory 2" > file2.txt

>> sudo docker build -t workdir-demo .
>> sudo docker run -it workdir-demo bash 
>> pwd  -> o/p -> /my-work-dir-2

RUN vs CMD vs ENTRYPOINT :

RUN apt-get -y install firefox
CMD echo "GeeksforGeeks"
ENTRYPOINT echo "GeeksforGeeks"

Both the above commands outputs “GeeksforGeeks”. The shell form of execution commands is generally used for RUN commands.

> When you use a RUN command in your dockerfile, it always creates a new intermediate image layer on top of the previous ones. That’s why it is always recommended chaining all the RUN commands together.

> A CMD command is used to set a default command that gets executed once you run the Docker Container. In case you provide a command with the Docker run command, the CMD arguments get ignored from the dockerfile. In the case of multiple CMD commands, only the last one gets executed.

CMD ["python3", "app.py"]

If we use additional arguments along with the docker run command such as “bash”, it will simple open the bash and not echo anything.

> An ENTRYPOINT command, unlike CMD, does not ignore additional parameters that you specify in your Docker run command.

Consider the example below:

ENTRYPOINT ["echo", "Geeksforgeeks "]
CMD ["Docker Tutorials"]



